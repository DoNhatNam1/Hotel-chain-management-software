import { CompositeType, FieldDefinition, Operation, Schema, SchemaRootKind } from "@apollo/federation-internals";
import { Edge, QueryGraph, RootPath, Transition, TransitionPathWithLazyIndirectPaths, RootVertex, ConditionResolver } from "@apollo/query-graphs";
import { CompositionHint } from "./hints";
import { GraphQLError } from "graphql";
export declare class ValidationError extends Error {
    readonly supergraphUnsatisfiablePath: RootPath<Transition>;
    readonly subgraphsPaths: RootPath<Transition>[];
    readonly witness: Operation;
    constructor(message: string, supergraphUnsatisfiablePath: RootPath<Transition>, subgraphsPaths: RootPath<Transition>[], witness: Operation);
}
export declare function validateGraphComposition(supergraphSchema: Schema, supergraphAPI: QueryGraph, federatedQueryGraph: QueryGraph): {
    errors?: GraphQLError[];
    hints?: CompositionHint[];
};
export declare function computeSubgraphPaths(supergraphSchema: Schema, supergraphPath: RootPath<Transition>, federatedQueryGraph: QueryGraph, overrideConditions: Map<string, boolean>): {
    traversal?: ValidationState;
    isComplete?: boolean;
    error?: GraphQLError;
};
export declare function extractValidationError(error: any): ValidationError | undefined;
export declare class ValidationContext {
    readonly supergraphSchema: Schema;
    private readonly joinTypeDirective;
    private readonly joinFieldDirective;
    constructor(supergraphSchema: Schema);
    isShareable(field: FieldDefinition<CompositeType>): boolean;
}
export declare class ValidationState {
    readonly supergraphPath: RootPath<Transition>;
    readonly subgraphPaths: TransitionPathWithLazyIndirectPaths<RootVertex>[];
    selectedOverrideConditions: Map<string, boolean>;
    constructor(supergraphPath: RootPath<Transition>, subgraphPaths: TransitionPathWithLazyIndirectPaths<RootVertex>[], selectedOverrideConditions?: Map<string, boolean>);
    static initial({ supergraphAPI, kind, federatedQueryGraph, conditionResolver, overrideConditions, }: {
        supergraphAPI: QueryGraph;
        kind: SchemaRootKind;
        federatedQueryGraph: QueryGraph;
        conditionResolver: ConditionResolver;
        overrideConditions: Map<string, boolean>;
    }): ValidationState;
    validateTransition(context: ValidationContext, supergraphEdge: Edge): {
        state?: ValidationState;
        error?: GraphQLError;
        hint?: CompositionHint;
    };
    currentSubgraphNames(): string[];
    currentSubgraphs(): {
        name: string;
        schema: Schema;
    }[];
    toString(): string;
}
//# sourceMappingURL=validate.d.ts.map